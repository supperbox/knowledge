# 渲染机制：Virtual DOM + 高效更新

## 1. 这是什么

Vue 组件渲染大致分两步：

1. 编译：模板 -> 渲染函数（render）
2. 运行：render 产生 Virtual DOM（VNode）-> diff -> patch 到真实 DOM

Vue 3 的重点（编译期优化）：让“找茬游戏”带上地图

- **1. 静态提升 (Static Hoisting) —— “搬出杂物”**
  - **白话**：将模板中永远不会变的静态内容（如纯文本、纯图标）移出 `render` 函数。
  - **效果**：这些节点**只会在初始化时创建一次**，后续渲染直接复用同一个内存引用。不仅省了内存，还在对比时让 Vue 一眼通过 `old === new` 判定跳过，完全消除了重复重建 VNode 的开销。

- **2. Patch Flags (动态标记) —— “精准标记”**
  - **白话**：在生成动态 VNode 时，贴上一个数字标签（如 `1` 代表文字变，`2` 代表 class 变）。
  - **效果**：运行时 Diff 算法不再盲目对比所有属性，而是根据标签**精准只比对**可能变化的那一项。比如标记了 `:class`，Vue 就会跳过对 `id`、`name` 等静态属性的检查。

- **3. Block Tree (块级更新) —— “结构化稳态”**
  - **深度理解与用法（为什么叫“树”）：**
    - **背景**：平坦数组（Flat List）提速的前提是**结构必须稳定**。但模板中有 `v-if` 和 `v-for`，它们会动态增删 DOM，破坏结构的稳定性。
    - **原理**：Vue 3 并非把整个组件只做成一个大数组，而是遇到“不稳定结构”就切分。
      - 每个 `v-if` 的分支、每个 `v-for` 的循环体，都会被视为一个独立的 **Block**。
      - 根 Block 就像一个大盒子，里面放着稳定的动态节点，和几个“子盒子”（子 Block）。
    - **核心逻辑示例**：
      ```html
      <div>
        <!-- Block 1 (Root) -->
        <p>{{ title }}</p>
        <!-- 根 Block 的动态节点 1 -->
        <div v-if="ok">
          <!-- 遇到结构变化，划分为 Block 2 (Sub-Block) -->
          <span>{{ msg }}</span>
          <!-- 子 Block 2 的动态节点 -->
        </div>
      </div>
      ```
    - **为什么要变回“树”？**
      - 当 `ok` 切换时，Vue 只需要比对 `Block 1` 下的 `Block 2` 是否需要切换。
      - 而在每个 Block 内部，节点顺序永远不变，依然可以**像传送门一样**跳过所有静态节点，直接操作数组里的动态节点。
    - **结论**：Block Tree 是用“树的层级”包裹了“本地的平坦列表”，既处理了复杂的动态结构，又最大限度保留了跳过静态节点的性能。

### 三者如何协同工作？（公式总结）

**Block (容器)** + **Dynamic Children (平坦数组)** + **Patch Flags (更新标签)** = **高性能更新**

- **Block** 解决了“去哪找”的问题（跳过静态树）；
- **平坦数组** 解决了“怎么快”的问题（直接闪现到动态节点）；
- **Patch Flags** 解决了“改哪里”的问题（精准修改属性，不瞎找茬）。

> **直白结论**：Block 是容器，它通过“扁平数组”收集了带有“Patch Flags”的动态节点；而遇到 `v-if` 时，它会生成“子 Block”来确保结构变化时，对比依然是高效且安全的。

#### 更加精确的细节拆解：

1.  **数组里存的是什么？**
    - 不是存的 flags 数值，而是存的带有 flags 的 **VNode 引用**。
    - 比如一个 Block 内部有 1000 个节点，只有 3 个是动态的。那么这个 Block 的数组里**只存这 3 个节点的引用**。
    - **更新时**：Vue 直接遍历这 3 个节点，然后根据它们身上的 Flags（比如 `1` 代表文字变化）去精准更新，完全无视剩下的 997 个节点。

2.  **为什么 v-if 必须生成子 Block？**
    - **核心痛点**：如果你把 `v-if` 里的动态节点也塞进父 Block 的扁平数组，那么当 `v-if` 隐藏时，数组里的节点位置就乱了，Vue 无法准确定位。
    - **解决方式**：`v-if` 的每个分支都是一个独立的**子 Block**。
    - **对比流程**：
      - **父 Block 更新**：先“闪现”更新自己数组里的动态节点。
      - **遇到子 Block (v-if)**：先看 `v-if` 的条件变没变。
      - **如果条件没变**：进入子 Block，继续用子 Block 的“扁平数组”闪现更新。
      - **如果条件变了**：直接整个替换/卸载掉这个子 Block。

从而显著减少运行时 diff 与内存占用。

## 3. 编译流程：如何落地这些优化？

编译不是简单的“翻译”，而是一次**深度的静态分析**。

1.  **Parse (解析阶段)**：
    - 将模板字符串转换成 **AST (抽象语法树)**。此时它只是一个描述结构的 JS 对象。
2.  **Transform (转换阶段) —— 优化的核心**：
    - **找茬与打标 (Patch Flags)**：遍历 AST，当发现节点有 `:id="xxx"` 或 `{{ msg }}` 时，就在 AST 节点上标记一个 Patch Flag 位。
    - **提取静态物 (Hoisting)**：发现节点及其子树完全不涉及变量，就将该 AST 节点标记为“可提升”，并将其移出当前的 AST 树，存入一个全局变量池。
    - **建立 Block 追踪**：识别 `v-if` / `v-for` 等指令，并在对应的 AST 节点上开启“追踪模式”，记录其下的动态子节点，形成 Block 结构。
3.  **Codegen (代码生成阶段)**：
    - 将优化后的 AST 产出为最终的 **Render 函数**。
    - 静态节点会被生成为全局常量；动态节点会带上 Patch Flag 数字；渲染逻辑会被包裹在 `_openBlock()` 和 `_createElementBlock()` 之中。

## 4. 你需要知道的“性能开关”

- `v-if`/`v-show` 的选择
- `v-for` 的 key 稳定性
- 避免在模板中频繁调用函数
- 大列表：考虑虚拟列表（组件库/自研）

### 核心原理：v-for 中 key 的作用

在 `v-for` 中使用 `key` 是 Diff 算法高效运转的基石。

#### 无 key：就地更新 (In-place patch)

- **行为**：如果列表顺序改变（如：[A, B, C] 变成 [B, A, C]），Vue 不会移动 DOM 元素，而是直接修改每个索引位置上的 DOM 内容，使其匹配新数据。
- **代价**：
  - 如果子树很复杂，修改属性的开销可能比移动 DOM 更大。
  - **副作用**：无法维持组件或表单项的内部状态（如输入框里的文字、正在播放的视频）。

#### 有 key：身份标识与最小移动

- **行为**：`key` 是 VNode 的唯一身份证。通过对比 `key`，Vue 可以在新旧列表中精准识别出“谁是谁”。
- **LIS 算法 (Longest Increasing Subsequence) 详解**：
  - **核心目标**：在乱序的新旧列表中，找到**相对位置没有发生变化**的最佳子集。
  - **为什么需要它？** 假设旧列表是 `[A, B, C, D]`，新列表变成 `[B, C, A, D]`。
    - 如果我们发现 `B` 和 `C` 的相对顺序没变（都是 B 在 C 前面），那么我们只需要把 `A` 挪走，而不需要动 `B`、`C` 和 `D`。
    - LIS 算法能算出 `[B, C, D]` 这个最长子序列，告诉 Vue：这几个节点原地不动，只移动剩下的节点。
  - **数学逻辑**：
    1. 生成一个数组 `source`，记录新节点在旧列表中的索引下标。
    2. 计算该 `source` 数组的最长递增子序列。
    3. 结果是一个包含位置索引的数组，代表哪些位置的 DOM **不需要移动**。
  - **复杂度优化**：Vue 3 使用了基于二分查找和贪心策略的优化 LIS 算法，将复杂度降为 $O(n \log n)$。
- **效果**：极大地减少了浏览器的 `appendChild` 和 `insertBefore` 等 DOM 操作，这是 Vue 3 Diff 算法比 Vue 2（双端比较）在处理乱序列表时更高效的核心原因。

## 5. 渲染触发来源

- 响应式依赖变化（ref/reactive/computed）
- props 变化
- 父组件重新渲染导致子组件更新（取决于依赖与静态提升）

## 6. 优化手段（深度实践）

### ① 昂贵计算与 `computed` —— “内存换时间”

- **原理**：`render` 函数在每次组件更新时都会执行。如果你在模板中直接写 `items.filter(...).map(...)`，那么每次更新（即使是无关的数据变动）都会重新计算。
- **做法**：将逻辑移入 `computed`。
- **收益**：`computed` 具有**缓存机制**，只有当依赖的响应式数据真正变化时才会重新执行。

### ② 常量提取与 `markRaw` —— “跳过响应式劫持”

- **场景**：
  - **组件外常量**：完全不会变的配置项、图标映射表等，直接定义在 `<script setup>` 之外或顶部。
  - **巨大数据**：如果有一个上万节点的组织架构树，且只需要展示不需要修改，使用 `reactive` 会导致 Vue 递归递归地为每个属性建立 Proxy，耗费大量性能。
- **做法**：使用 `markRaw(bigData)`。
- **收益**：告诉 Vue “这个对象永远不需要响应式”，从而完全跳过 Proxy 劫持，减少内存占用和初始化耗时。

### ③ 维持稳定的 `key` —— “精准复用 DOM”

- **核心禁忌**：**不要用 `index` 做 `key`**（除非列表是静态且永远不排序/过滤的）。
- **后果**：如果用 `index`，在列表头部插入一条数据时，所有后续节点的 `index` 都会变，导致 Vue 认为所有节点都变了，从而销毁并重建所有 DOM。
- **做法**：使用唯一的业务 ID（如 `item.id`）。

### ④ 子组件“输入最小化” —— “拦截无效更新”

- **原理**：Vue 3 虽然由于 Patch Flags 非常快，但父组件重新渲染时，如果传给子组件的 Props 是一个**新对象引用**，子组件仍可能触发更新检查。
- **优化点**：
  - **传基本类型**：尽量只传子组件需要的 ID 或 String，而不是一整个大对象。
  - **稳定引用**：如果必须传对象，确保这个对象不是在 `render` 中临时生成的（如 `:style="{ color: 'red' }"` 会导致每次都是新对象，应提取到常量或 `computed`）。
- **终极手段**：如果子组件足够复杂，可以使用 `shallowRef` 或在必要时结合 `v-memo`（Vue 3.2+）来手动锁定一段模板的更新。

## 7. 常见坑

- “为什么我改了对象字段 UI 没更新？”
  - 可能是非响应式对象（markRaw/普通对象）或丢失响应性（解构）
- “列表渲染错乱/复用错误”
  - key 不稳定或 key 冲突
- “渲染频繁导致卡顿”
  - watchEffect 引入过多依赖；模板函数调用；大列表无虚拟化

## 7. 最小示例：避免模板函数调用

```vue
<script setup lang="ts">
import { computed } from "vue";

const props = defineProps<{ items: { id: string; name: string }[] }>();
const names = computed(() => props.items.map((i) => i.name).join(","));
</script>

<template>
  <div>{{ names }}</div>
</template>
```
