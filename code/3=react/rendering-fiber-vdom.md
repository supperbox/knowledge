# Rendering 与 Fiber 架构

## 1. 虚拟 DOM (VDOM) 与渲染流

React 在内存中维护一棵轻量级的 DOM 树（实质是对象集合）。

### 渲染的两大阶段

1. **Render 阶段 (计算差异)**：
   - 遍历组件树，执行函数或实例化类。
   - 比较新旧 VDOM（Diffing）。
   - **特点**：异步且可中断（由 Fiber 调度）。
2. **Commit 阶段 (应用变更)**：
   - 将 Render 阶段计算出的变更（Effect List）一次性同步到真实 DOM。
   - 执行生命周期钩子（如 `useEffect` 的副作用）。
   - **特点**：同步且不可中断，确保界面一致性。

---

## 2. Fiber 架构：让渲染动起来

Fiber 是 React 16 重构后的核心算法，它将原本“一撸到底”的递归渲染改为“工作单元”循环。

### 2.1 为什么要 Fiber？

在 Fiber 之前（Stack Reconciler），React 像递归调用函数一样渲染组件。如果树太深，主线程会被长时间占用，用户输入或动画就会卡顿。

### 2.2 Fiber 的核心设计

- **任务切片**：将整棵树的更新拆分为多个小的 Fiber 节点（每个组件/DOM 节点都是一个 Fiber）。
- **可中断机制**：利用 `requestIdleCallback` 原理，在浏览器空闲时执行。如果有更高优先级的任务（如键盘输入），先暂停渲染，处理输入，之后恢复渲染。
- **双缓冲技术**：同时存在 `current` 树（当前屏幕显示的）和 `workInProgress` 树（正在构建的）。渲染完成后，只需改变根节点的指针即可完成“换页”。

---

## 3. Diff 算法：最小化更新

React 的 Diff 算法基于两个启发式假设，将 $O(n^3)$ 的复杂度降为 $O(n)$：

### 3.1 核心规则

1. **同层比较**：React 只比较同级元素。如果父节点变了，直接销毁整棵子树并重建。
2. **类型检查**：同一个位置，如果元素类型不同（如 `<div>` 变成 `<span>`），React 直接删除旧的及其子树，创建新的。
3. **Key 标识**：在列表渲染中，`key` 是唯一的 ID。
   - **Key 没变**：复用该 DOM，仅更新内容（Patch）。
   - **Key 变了**：销毁并重建。

### 3.2 为什么不要用 Index 作为 Key？

如果列表发生了排序或插入，使用数组 index 作为 key 会导致：

- 错误的 DOM 复用（例如：在第 0 位插入新元素，原来的第 0 位元素依然会被复用，导致显示内容错乱或输入框内容没动）。
- 性能下降（原本可以复用的节点被迫重新渲染）。

---

## 4. 批处理 (Batching)

### 4.1 什么是批处理？

React 会将同一个事件处理函数内的多次 `setState` 合并。

```javascript
function handleClick() {
  setCount((c) => c + 1);
  setFlag((f) => !f);
  // 只会触发 1 次渲染，而不是 2 次
}
```

### 4.2 React 18 的自动批处理 (Automatic Batching)

在 React 18 之前，Promise、setTimeout 或原生 DOM 事件中的更新不会被合并。
**React 18 开始**，所有环境下的更新都会自动合并。

---

## 5. 性能优化建议

1. **避免不必要的渲染**：使用 `React.memo` 包裹纯组件，或使用 `useMemo`/`useCallback` 稳定 Props。
2. **状态裁剪**：不要在 State 中存放可以由 Props 派生出的数据。
3. **合理拆分组件**：粒度太粗会导致“一人变动，全家重绘”。
